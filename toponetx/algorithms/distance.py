"""Module to compute distance between nodes or cells on topological domains."""
from collections.abc import Collection, Hashable, Iterable, Iterator
from typing import Union
from warnings import warn

import networkx as nx
import numpy as np

from toponetx.classes.cell import Cell
from toponetx.classes.cell_complex import CellComplex
from toponetx.classes.colored_hypergraph import ColoredHyperGraph
from toponetx.classes.combinatorial_complex import CombinatorialComplex
from toponetx.classes.complex import Complex
from toponetx.classes.hyperedge import HyperEdge
from toponetx.classes.simplicial_complex import SimplicialComplex

__all__ = ["distance", "cell_distance"]


def distance(complex: Complex, source: Hashable, target: Hashable, s: int = 1) -> int:
    """Return shortest s-walk distance between two nodes in the cell complex.

    Parameters
    ----------
    complex : Complex.
        Supported complexes are cell/combintorial and hypegraphs.
    source : Hashable
        A node in the input complex.
    target : Hashable
        A node in the input complex.
    s : int, optional
        The number of intersections between pairwise consecutive cells.

    Returns
    -------
    s_walk_distance : int

    See Also
    --------
    cell_distance

    Notes
    -----
    The s-distance is the shortest s-walk length between the nodes.
    An s-walk between nodes is a sequence of nodes that pairwise share
    at least s cells. The length of the shortest s-walk is 1 less than
    the number of nodes in the path sequence.

    Uses the networkx shortest_path_length method on the graph
    generated by the s-adjacency matrix.

    Examples
    --------
    >>> CC = CellComplex()
    >>> CC.add_cell([2,3,4],rank=2)
    >>> CC.add_cell([5,6,7],rank=2)
    >>> list(node_diameters(CC))
    >>> CCC = CC.to_combinatorial_complex()
    >>> list(node_diameters(CCC))
    >>> CHG = CC.to_colored_hypergraph()
    >>> list(node_diameters(CHG))
    """
    if not isinstance(complex, (CellComplex, CombinatorialComplex, ColoredHyperGraph)):
        raise ValueError(f"Input complex {complex} is not supported.")
    if isinstance(source, Cell):
        source = source.elements
    if isinstance(target, Cell):
        target = target.elements
    if isinstance(source, Iterable):
        source = tuple(source)
    if isinstance(target, Iterable):
        target = tuple(target)
    rowdict, A = complex.node_to_all_cell_adjacnecy_matrix(index=True)
    G = nx.from_scipy_sparse_array(A)
    try:
        path = nx.shortest_path_length(G, rowdict[source], rowdict[target])
        return path
    except Exception:
        warn(f"No {s}-path between {source} and {target}")
        return np.inf


def cell_distance(
    complex: Complex,
    source: Union[Iterable, HyperEdge, Cell],
    target: Union[Iterable, HyperEdge, Cell],
    s: int = 1,
) -> int:
    """Return the shortest s-walk distance between two cells in the cell complex.

    Parameters
    ----------
    complex : Complex
        Supported complexes are cell/combintorial and hypegraphs.
    source : Union[Iterable, HyperEdge, Cell]
        An Iterable representing a cell in the input complex cell complex.
    target : Union[Iterable, HyperEdge, Cell]
        An Iterable representing a cell in the input complex cell complex.
    s : int
        The number of intersections between pairwise consecutive cells.

    Returns
    -------
    int
        Shortest s-walk cell distance between `source` and `target`.
        A shortest s-walk is computed as a sequence of cells,
        the s-walk distance is the number of cells in the sequence
        minus 1. If no such path exists returns np.inf.

    See Also
    --------
    distance

    Notes
    -----
    The s-distance is the shortest s-walk length between the cells.
    An s-walk between cells is a sequence of cells such that consecutive pairwise
    cells intersect in at least s nodes. The length of the shortest s-walk is 1 less than
    the number of cells in the path sequence.

    Uses the networkx shortest_path_length method on the graph
    generated by the s-cell_adjacency matrix.

    Example
    -------
    >>> CC = CellComplex()
    >>> CC.add_cell([2,3,4],rank=2)
    >>> CC.add_cell([5,6,7],rank=2)
    >>> CC.add_cell([5,2],rank=1)
    >>> cell_distance(CC, [2,3] ,[6,7])
    >>> CHG = CC.to_colored_hypergraph()
    >>> cell_distance(CHG, (frozenset({2, 3}), 0) ,(frozenset({6, 7}), 0))
    >>> CCC = CC.to_combinatorial_complex()
    >>> cell_distance(CCC, frozenset({2, 3}) ,frozenset({6, 7}))
    """
    if not isinstance(complex, (CellComplex, CombinatorialComplex, ColoredHyperGraph)):
        raise ValueError(f"Input complex {complex} is not supported.")
    if isinstance(source, (Cell, HyperEdge)):
        source = source.elements
    if isinstance(target, (Cell, HyperEdge)):
        target = target.elements
    if isinstance(complex, CellComplex):
        if isinstance(source, Iterable):
            source = tuple(source)
        if isinstance(target, Iterable):
            target = tuple(target)
    cell_dict, A = complex.all_cell_to_node_coadjacnecy_matrix(s=s, index=True)
    G = nx.from_scipy_sparse_array(A)
    try:
        path_distance = nx.shortest_path_length(G, cell_dict[source], cell_dict[target])
        return path_distance
    except Exception:
        warn(f"No {s}-path between {source} and {target}")
        return np.inf
